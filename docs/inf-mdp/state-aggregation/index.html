<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Aditya Mahajan" />
  <meta name="title" content="ECSE 506: Stochastic Control and Decision Theory" />
  <title>ECSE 506: Stochastic Control and Decision Theory</title>
  
  <meta content="infinite horizon,discounted cost,Lipschitz continuity,approximation bounds,state aggregation" name="keywords" />
  

  <link rel="stylesheet" href="https://adityam.github.io/stochastic-control//css/style.css" type="text/css" /><script type="text/javascript"
    src="https://adityam.github.io/stochastic-control/js/mathjax-local.js" defer>
  </script>
  <script type="text/javascript" id="MathJax-script" defer
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
  </script>

  <script type="module" defer
    src="//instant.page/3.0.0"
    integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1">
  </script>

  <script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101261731);</script>
  <script async src="//static.getclicky.com/js"></script>

</head>
<body>
<div id="content">
<div class="title">
  <h1>ECSE 506: Stochastic Control and Decision Theory </h1>
  <h2><a href="http://www.cim.mcgill.ca/~adityam/">Aditya Mahajan</a> <br/>
      Winter 2022
  </h2>
  <h3><a href="https://adityam.github.io/stochastic-control/ ">About</a>
	&nbsp;<small><small>|</small></small>&nbsp;
    <a href="https://adityam.github.io/stochastic-control//lectures">Lectures</a></span>
	&nbsp;<small><small>|</small></small>&nbsp;
    <a href="https://adityam.github.io/stochastic-control//notes">Notes</a></span>
	&nbsp;<small><small>|</small></small>&nbsp;
    <a href="https://adityam.github.io/stochastic-control//coursework">Coursework</a>
</h3>
</div>



<div class="h1-title">Theory: State aggregation or discretization or quantization</div>

<p>So far, we have studied exact solutions to the dynamic program. When the state space is large (or possibly continuous), an exact solution is not possible due to computational limitations. So, we need to look at approximate solutions.</p>
<p>The simplest form of approximate solution is <strong>state aggregation</strong>, in which we partition the state space into equivalence classes and assign one state in each class as a representative element of that class. When the state space is continuous, the procedure is called <strong>state discretization</strong> or <strong>state quantization</strong>. We will use the state quantization terminology in these notes.</p>
<h1 data-number="1" id="system-model"><span class="header-section-number">1</span> System model</h1>
<p>Consider an MDP with abstract state space <span class="math inline">\(\ALPHABET S\)</span> and finite action space <span class="math inline">\(\ALPHABET A\)</span>. We denote this MDP by <span class="math inline">\(M = (\ALPHABET S, \ALPHABET A, c, p)\)</span>. For simplicity, we assume that <span class="math inline">\(\ALPHABET S\)</span> is continuous (and compact), and that the <span class="math inline">\(p\)</span> is the density of the transition kernel. Note that we are using the term “probability density” in the engineering sense (so, it may be a combination of a continuous function and delta functions) rather than in the precise measure theoretic sense (where it is the Radon-Nikodym derivative with respect to the Lebesque measure).</p>
<p>If exact computations were possible, we can find an optimal solution by solving the following dynamic program: <span class="math display">\[ V = \mathcal B V, \]</span> that is <span class="math display">\[ V(s) = 
\min_{a \in \ALPHABET A} \biggl\{ c(s,a) 
+ \gamma \int_{\ALPHABET S} p(s&#39;|s,a) V(s&#39;) ds&#39; \biggr\},
\quad \forall s \in \ALPHABET S.
\]</span> Let <span class="math inline">\(V^*\)</span> denote the optimal value function and <span class="math inline">\(π^*\)</span> denote the optimal policy.</p>
<p>However, since the state space is continuous, we cannot compute the value functions exactly. The simplest way to proceed is to discretize or quantize the state space <span class="math inline">\(\ALPHABET S\)</span>. In particular, let <span class="math inline">\(\{\ALPHABET S_1, \dots \ALPHABET S_n\}\)</span> denote a partition of <span class="math inline">\(\ALPHABET S\)</span> (i.e., <span class="math inline">\(\bigcup_{i=1}^n \ALPHABET S_i = \ALPHABET S\)</span> and for any <span class="math inline">\(i \neq j\)</span>, <span class="math inline">\(\ALPHABET S_i \cap \ALPHABET S_j = \emptyset\)</span>). Pick a representative point <span class="math inline">\(\hat s_i \in \ALPHABET S_i\)</span>. We can think of the “grid points” <span class="math inline">\(\hat {\ALPHABET S} = \{\hat s_1, \dots, \hat s_n\}\)</span> as quantization of the state space <span class="math inline">\(\ALPHABET S\)</span>. To simplify the notation, we define a quantization function <span class="math inline">\(\phi \colon \ALPHABET S \to \hat {\ALPHABET  S}\)</span> which maps all points in <span class="math inline">\(\ALPHABET S_i\)</span> to the representative element <span class="math inline">\(\hat s_i\)</span>.</p>
<p>We consider a finite state MDP <span class="math inline">\(\hat M = (\hat {\ALPHABET S}, \ALPHABET A, \hat c, \hat P)\)</span>, where <span class="math inline">\(\hat c\)</span> is the restriction of <span class="math inline">\(c\)</span> onto <span class="math inline">\(\hat {\ALPHABET S}\)</span>, and <span class="math inline">\(\hat P\)</span> is given by <span class="math display">\[\hat P(\hat s_j | \hat s_i, a) =
\int_{\ALPHABET S_j} p(s&#39; | \hat s_i, a) dy = p(\ALPHABET S_j | \hat s_i, a).
\]</span></p>
<p>Suppose <span class="math inline">\(\hat W^* \colon \hat S \to \reals\)</span> be the optimal value function and <span class="math inline">\(\hat μ^* \colon \hat {\ALPHABET S} \to \ALPHABET A\)</span> be the optimal policy for the approximate model. Define <span class="math inline">\(W^* \colon \ALPHABET S \to \reals\)</span> and <span class="math inline">\(μ^* \colon \ALPHABET S \to \reals\)</span> to be piecewise constant extrapolation of <span class="math inline">\(\hat W^*\)</span> and <span class="math inline">\(\hat μ^*\)</span> from <span class="math inline">\(\hat {\ALPHABET S}\)</span> to <span class="math inline">\(\ALPHABET S\)</span>, i.e., <span class="math display">\[
W^*(s) = \hat W^*(\phi(s)) 
\quad\text{and}\quad
μ^*(s) = \hat μ^*(\phi(s)).
\]</span> Note that the policy <span class="math inline">\(μ^*\)</span> chooses the same action on all states in a quantization cell <span class="math inline">\(\ALPHABET S_i\)</span>.</p>
<p>We are interested in two questions:</p>
<ol type="1">
<li><strong>Error in value approximation:</strong> What is the error if <span class="math inline">\(W^*\)</span> is used as an approximation for <span class="math inline">\(V^*\)</span>?</li>
<li><strong>Error in policy approximation:</strong> What is the error if the policy <span class="math inline">\(μ^*\)</span> is used instead of the optimal policy <span class="math inline">\(π^*\)</span>?</li>
</ol>
<!--
We present two methods to bound the two approximation errors. The first method
bounds the errors in terms of the Lipschitz constant of $V^*$ while the second
method bounds the errors in terms of the Lipschitz constant of $\hat W^*$.
-->
<h1 data-number="2" id="bounds-on-value-and-policy-approximation-error"><span class="header-section-number">2</span> Bounds on value and policy approximation error</h1>
<h2 data-number="2.1" id="preliminary-results"><span class="header-section-number">2.1</span> Preliminary results</h2>
<p>We start by some preliminary results to build the intuition behind the approximation bounds. We start with a property of the discretized transition matrix.</p>
<div class="highlight">
<dl>
<dt><span id="lemma:1"></span><span id="lemma:pmf" class="pandoc-numbering-text lemma"><strong>Lemma 1</strong></span></dt>
<dd>
<p>For any <span class="math inline">\(\hat V \colon \hat {\ALPHABET S} \to \reals\)</span>, let <span class="math inline">\(V \colon \ALPHABET S \to \reals\)</span> be its piecewise constant extrapolation from <span class="math inline">\(\hat {\ALPHABET S}\)</span> to <span class="math inline">\(\ALPHABET S\)</span> (i.e., <span class="math inline">\(V = \hat V \circ \phi\)</span>). Then, for any <span class="math inline">\(\hat s \in \ALPHABET S\)</span> and <span class="math inline">\(a \in \ALPHABET A\)</span>, we have <span class="math display">\[
\int_{\ALPHABET S} p(s&#39; | \hat s,a) V(s&#39;) ds&#39; 
=
\sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat P(\hat s&#39; | \hat s, a) 
\hat V(\hat s&#39;).
\]</span></p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof">Proof</h4>
</summary>
<div>
<p>Recall that <span class="math inline">\(\{\ALPHABET S_1, \dots, \ALPHABET S_n\}\)</span> is a partition of <span class="math inline">\(\ALPHABET S\)</span> and <span class="math inline">\(\ALPHABET S_i = \phi^{-1}(\hat s_i)\)</span>. Therefore, <span class="math display">\[\begin{align*}
\int_{\ALPHABET S} p(s&#39;|\hat s, a) V(s&#39;) ds&#39; 
&amp;= \sum_{\hat s&#39; \in \hat {\ALPHABET S}} 
\int_{\phi^{-1}(\hat s&#39;)} p(s&#39; | \hat s; a) \hat V(\phi(s&#39;)) ds&#39;
\\
&amp;= \sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat V(\hat s&#39;) 
\int_{\phi^{-1}(\hat s&#39;)} p(s&#39; | \hat s; a) ds&#39;
\\
&amp;= \sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat V(\hat s&#39;) 
\hat P(\hat s&#39; | \hat s, a).
\end{align*}\]</span></p>
</div>
</details>
<p>An immediate consequence of <a href="#lemma:pmf" title="Lemma 1"><span class="pandoc-numbering-link lemma">Lemma 1</span></a> is the following:</p>
<div class="highlight">
<dl>
<dt><span id="lemma:2"></span><span id="lemma:one-step" class="pandoc-numbering-text lemma"><strong>Lemma 2</strong></span></dt>
<dd>
<p>For any <span class="math inline">\(\hat V \colon \hat {\ALPHABET S} \to \reals\)</span>, let <span class="math inline">\(V \colon \ALPHABET S \to \reals\)</span> be its piecewise constant extrapolation from <span class="math inline">\(\hat {\ALPHABET S}\)</span> to <span class="math inline">\(\ALPHABET S\)</span> (i.e., <span class="math inline">\(V = \hat V \circ \phi\)</span>). Define, one-step update functions: <span class="math display">\[\begin{align}
  W(s) &amp;= \min_{a \in \ALPHABET A}\biggl\{
  c(s,a) + γ \int_{\ALPHABET S} p(s&#39; | s,a) V(s&#39;) ds&#39; \biggr\}, 
  \label{eq:one-step-a}\\ 
  \hat W(\hat s) &amp;= \min_{a \in \ALPHABET  A} \biggl\{
  \hat c(\hat s,a) + γ \sum_{\hat s \in \ALPHABET S} \hat P(\hat s&#39; | s,a) \hat
  V(\hat s&#39;) \biggr\}.
  \label{eq:one-step-b}
\end{align}\]</span> Then, <span class="math display">\[\begin{equation}\label{eq:one-step}
  W(\hat s) = \hat W(\hat s), \quad \forall \hat s \in \hat {\ALPHABET S}.
\end{equation}\]</span></p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof-1">Proof</h4>
</summary>
<div>
<p>Let <span class="math inline">\(π\)</span> be the optimal policy for \eqref{eq:one-step-a} and <span class="math inline">\(\hat π\)</span> be the optimal policy for \eqref{eq:one-step-b}. Fix a state <span class="math inline">\(\hat s \in \hat {\ALPHABET S}\)</span> and let <span class="math inline">\(a = π(\hat s)\)</span> and <span class="math inline">\(\hat a = \hat π(\hat s)\)</span>. Then, <span class="math display">\[\begin{align*}
W(\hat s) &amp;= c(\hat s, a) + γ \int_{\ALPHABET S}
  p( s&#39; | \hat s, a) V(s&#39;) ds&#39;
\\
&amp;\stackrel{(a)}= \hat c(\hat s, a) + γ
\sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat P(\hat s&#39;|\hat s, a) \hat V(\hat
s&#39;)
\\
&amp;\ge \hat W(\hat s),
\end{align*}\]</span> where <span class="math inline">\((a)\)</span> follows from definition of <span class="math inline">\(\hat c\)</span> and <a href="#lemma:pmf" title="Lemma 1"><span class="pandoc-numbering-link lemma">Lemma 1</span></a>.</p>
<p>Similarly, we have <span class="math display">\[\begin{align*}
\hat W(\hat s) &amp;= \hat c(\hat s, \hat a) + γ
\sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat P(\hat s&#39;|\hat s, \hat a) \hat V(\hat
s&#39;)
\\
&amp;\stackrel{(b)}= c(\hat s, \hat a) + γ \int_{\ALPHABET S}
  p( s&#39; | \hat s, \hat a) \hat V(s&#39;) ds&#39;
\\
&amp;\ge W(\hat s),
\end{align*}\]</span> where <span class="math inline">\((b)\)</span> follows from definition of <span class="math inline">\(\hat c\)</span> and <a href="#lemma:pmf" title="Lemma 1"><span class="pandoc-numbering-link lemma">Lemma 1</span></a>.</p>
<p>Thus, <span class="math inline">\(W(\hat s) = \hat W(\hat s)\)</span>.</p>
</div>
</details>
<p><a href="#lemma:pmf" title="Lemma 1"><span class="pandoc-numbering-link lemma">Lemma 1</span></a> shows that for any quantization point <span class="math inline">\(\hat s\)</span> and action <span class="math inline">\(a\)</span>, computing the expectation of the future cost to go function <span class="math inline">\(\hat V \colon \hat {\ALPHABET S} \to \reals\)</span> with respect to the measure <span class="math inline">\(\hat P\)</span> is the same as computing the expectation of the piecewise linear extrapolation <span class="math inline">\(V\)</span> of <span class="math inline">\(\hat V\)</span> with respect to the original measure <span class="math inline">\(p\)</span>. <a href="#lemma:one-step" title="Lemma 2"><span class="pandoc-numbering-link lemma">Lemma 2</span></a> shows that the one step Bellman update of a function <span class="math inline">\(\hat V\)</span> coincides with the one-step Bellman update of its piecewise constant extrapolation <span class="math inline">\(V\)</span> at quantization points <span class="math inline">\(\hat s \in \hat {\ALPHABET S}\)</span>.</p>
<p>Note that these equivalences are valid only at quantization points <span class="math inline">\(\hat s \in \hat {\ALPHABET S}\)</span> and not for other points in <span class="math inline">\(\ALPHABET S\)</span>.</p>
<h2 data-number="2.2" id="bounding-the-error-for-value-function-approximation"><span class="header-section-number">2.2</span> Bounding the error for value function approximation</h2>
<p>We will present two bounds on the value function approximation. For the first bound, define <span class="math display">\[
  H_{\max} = \sup_{s \in \ALPHABET S}| V^*(s) - V^*(\phi(s)) |.
\]</span></p>
<p>Then, we can bound the error for value function approximation as follows.</p>
<div class="highlight">
<dl>
<dt><span id="prop:1"></span><span id="prop:value0" class="pandoc-numbering-text prop"><strong>Proposition 1</strong></span></dt>
<dd>
<p><span class="math display">\[\NORM{ V^* - W^*}_∞ \le \frac{H_{\max}}{1-γ} . \]</span></p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof-2">Proof</h4>
</summary>
<div>
<p>Consider any <span class="math inline">\(s \in \ALPHABET S\)</span>. Then, <span class="math display">\[\begin{align}
  \bigl| V^*(s) - W^*(s) \bigr| 
  &amp;\le \bigl| V^*(s) - V^*(\phi(s)) \bigr| + \bigl| V^*(\phi(s)) - \hat W^*(\phi(s)) \bigr|
  \notag \\
  &amp;\le H_{\max} + \bigl| V^*(\phi(s)) - \hat W^*(\phi(s)) \bigr|
  \label{eq:step-a-1}
\end{align}\]</span></p>
<p>For the ease of notation let <span class="math inline">\(\mathcal B\)</span> and <span class="math inline">\(\hat {\mathcal B}\)</span> denote the Bellman operators for model <span class="math inline">\(M\)</span> and <span class="math inline">\(\hat M\)</span>, respectively. Now, we know that <span class="math inline">\(\hat W^* = \hat {\mathcal B} \hat W^*\)</span> and by <a href="#lemma:one-step" title="Lemma 2"><span class="pandoc-numbering-link lemma">Lemma 2</span></a> <span class="math inline">\([\hat {\mathcal B} \hat W^*](\hat s) = [\mathcal B W^*](\hat s)\)</span>. Thus, we can write the second term of \eqref{eq:step-a-1} as follows: <span class="math display">\[\begin{align*}
  \bigl| V^*(\phi(s)) - \hat W^*(\phi(s)) \bigr| 
  &amp;=
  \bigl| [\mathcal B V^*](\phi(s)) - [ \mathcal B W^* ](\phi(s)) \bigr| 
  \\
  &amp;\le γ \NORM{V^* - W^*}_∞.
\end{align*}\]</span> Substituting back in \eqref{eq:step-a-1}, we get <span class="math display">\[\bigl| V^*(s) - W^*(s) \bigr| \le H_{\max} + γ \NORM{V^* - W^*}_∞.\]</span> We get the result by supermizing over <span class="math inline">\(s\)</span> and rearranging the terms.</p>
</div>
</details>
<p>Note that the result of <a href="#prop:value0" title="Proposition 1"><span class="pandoc-numbering-link prop">Proposition 1</span></a> is what is called an “instance-dependent” bound: it depends on the value function <span class="math inline">\(V^*\)</span>. In some situations, we want an ’instance-indendent” bound, which does not depend the value function.</p>
<p>As a first step to obtain an instance-indendent bound, we assume that <span class="math inline">\(\ALPHABET S\)</span> is a bounded metric space with metric <span class="math inline">\(d_S\)</span>. Suppose the original MDP <span class="math inline">\(M\)</span> satisfies some regularity properties such that the value function <span class="math inline">\(V^*\)</span> is Lipschitz with Lipschitz constant <span class="math inline">\(\NORM{V^*}_L\)</span>, i.e., for any <span class="math inline">\(s,s&#39; \in \ALPHABET S\)</span> <span class="math display">\[ \bigl| V^*(s) - V^*(s&#39;) \bigr| \le \NORM{V^*}_L d_S(s,s&#39;). \]</span> This means that for any <span class="math inline">\(s \in \ALPHABET S\)</span>, <span class="math display">\[\begin{equation}\label{eq:lip}
\bigl| V(s) - V(\phi(s)) \bigr| \le \NORM{V^*}_L D, 
\end{equation}\]</span> where <span class="math inline">\(D = \sup_{s \in \ALPHABET S} d_S(s,\phi(s))\)</span> is the largest <em>radius</em> of the quantization cells. Note that since <span class="math inline">\(\ALPHABET S\)</span> is assumed to be a bounded metric space, <span class="math inline">\(D\)</span> is finite. An immediate implication of \eqref{eq:lip} is that <span class="math display">\[
  H_{\max} \le \NORM{V^*}_L D.
\]</span></p>
<p>Substituting this in <a href="#prop:value0" title="Proposition 1"><span class="pandoc-numbering-link prop">Proposition 1</span></a>, we get</p>
<div class="highlight">
<dl>
<dt><span id="prop:2"></span><span id="prop:value" class="pandoc-numbering-text prop"><strong>Proposition 2</strong></span></dt>
<dd>
<p><span class="math display">\[\NORM{ V^* - W^*}_∞ \le \frac{D}{1-γ} \NORM{V^*}_L . \]</span></p>
</dd>
</dl>
</div>
<p>The advantage of the bound in <a href="#prop:value" title="Proposition 2"><span class="pandoc-numbering-link prop">Proposition 2</span></a> is that we can obtain an “instance-independent” upper bound on <span class="math inline">\(\NORM{V^*}_L\)</span>. In particular, assume that the model <span class="math inline">\(M\)</span> is a <span class="math inline">\((L_c, L_p)\)</span>-Lipschitz MDP.</p>
<dl>
<dt><span id="ass:1"></span><span id="ass:lip" class="pandoc-numbering-text ass"><strong>Assumpt. 1</strong></span></dt>
<dd>
<ul>
<li>For every <span class="math inline">\(a \in \ALPHABET A\)</span>, <span class="math inline">\(c(s, a)\)</span> is <span class="math inline">\(L_c\)</span>-Lipschitz in <span class="math inline">\(s\)</span></li>
<li>For every <span class="math inline">\(a \in \ALPHABET A\)</span>, <span class="math inline">\(p(\cdot | s, a)\)</span> is <span class="math inline">\(L_p\)</span>-Lipschitz in <span class="math inline">\(s\)</span> (with respect to the Kantorovich distance on probability measures).</li>
</ul>
</dd>
</dl>
<p>Under this assumption, <a href="../lipschitz-mdp#thm:Lipschitz-opt">Theorem 1 of Lipschitz MDPs</a>, implies that <span class="math inline">\(\NORM{V^*}_L \le L_c/(1 - γ L_p)\)</span>. Thus, we have the following:</p>
<div class="highlight">
<dl>
<dt><span id="cor:1"></span><span id="cor:value" class="pandoc-numbering-text cor"><strong>Corollary 1</strong></span></dt>
<dd>
<p>Under <a href="#ass:lip" title="Assumpt. 1"><span class="pandoc-numbering-link ass">Assumpt. 1</span></a>, if <span class="math inline">\(γ L_p &lt; 1\)</span>, then <span class="math display">\[
    \NORM{V^* - W^*}_∞ \le \frac{L_c}{(1-γ)(1-γL_p)} D.
\]</span></p>
</dd>
</dl>
</div>
<h2 data-number="2.3" id="bounding-the-error-for-policy-approximation"><span class="header-section-number">2.3</span> Bounding the error for policy approximation</h2>
<p>Using the same idea as <a href="#prop:value" title="Proposition 2"><span class="pandoc-numbering-link prop">Proposition 2</span></a>, it is possible to show that <span class="math display">\[
\NORM{V^{μ^*} - W^*}_∞ \le \frac{D}{1-γ} \NORM{V^{μ^*}}_L.
\]</span> Combining this with <a href="#prop:value" title="Proposition 2"><span class="pandoc-numbering-link prop">Proposition 2</span></a>, we get <span class="math display">\[
\NORM{V^{μ^*} - V^*}_∞ \le \NORM{V^{μ^*} - W^*}_∞ + \NORM{V^* - W^*}_∞
\le \frac{D}{1-γ} [ \NORM{V^*}_L + \NORM{V^{μ^*}}_L ].
\]</span></p>
<p>As in <a href="#cor:value" title="Corollary 1"><span class="pandoc-numbering-link cor">Corollary 1</span></a>, if we assume that the model is Lipschitz, then we can get a bound on <span class="math inline">\(\NORM{V^*}_L\)</span> in terms of Lipschitz constants on the cost function and the transition dynamics. However, it is difficult to bound <span class="math inline">\(\NORM{V^μ}_L\)</span> because that bound will be interms of the Lipschitz constant of the policy <span class="math inline">\(μ^* = \hat μ^* \circ \phi\)</span>. So, we provide an alternative bound on <span class="math inline">\(\NORM{V^{μ^*} - W^*}_∞\)</span> in this section.</p>
<div class="highlight">
<dl>
<dt><span id="prop:3"></span><span id="prop:policy" class="pandoc-numbering-text prop"><strong>Proposition 3</strong></span></dt>
<dd>
<p>Under <a href="#ass:lip" title="Assumpt. 1"><span class="pandoc-numbering-link ass">Assumpt. 1</span></a>, we have <span class="math display">\[\NORM{V^{μ^*} - V^*}_∞ \le 
  \frac{D}{1-γ} \biggl[ L_c + γ L_p \NORM{V^*}_L + 
  \frac{1 + γ}{1-γ} \NORM{V^*}_L \biggr]. \]</span></p>
<p>Furthermore, if <span class="math inline">\(γ L_p &lt; 1\)</span>, then from properties of Lipschitz MDPs, we know that <span class="math inline">\(\NORM{V^*}_L \le L_c/(1- γ L_p)\)</span>. Thus, <span class="math display">\[\NORM{V^{μ^*} - V^*}_∞ \le 
  \frac{2 D L_c }{ (1-γ)^2 (1-γ L_p) }. \]</span></p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof-3">Proof</h4>
</summary>
<div>
<p>Fix a state <span class="math inline">\(s \in \ALPHABET S\)</span>. Let <span class="math inline">\(\hat s = \phi(s)\)</span> and <span class="math inline">\(a = \hat μ^*(\hat s) = μ^*(s)\)</span>. By construction, <span class="math inline">\(W^*(s) = \hat W^*(\hat s)\)</span>. Thus, <span class="math display">\[\begin{align*}
W^*(s) &amp;= \hat W^*(\hat s) = c(\hat s, a) + γ \sum_{\hat s&#39; \in \hat {\ALPHABET S}}
\hat P(\hat s&#39; | \hat s, a) \hat W^*(\hat s&#39;).
\\
&amp;= c(\hat s, a) + γ \int_{\ALPHABET S} p(s&#39; | \hat s, a) W^*(s&#39;) ds&#39;.
\end{align*}\]</span> Moreover, <span class="math display">\[
V^{μ^*}(s) = c(s, a) + γ \int_{\ALPHABET S} 
p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39;.
\]</span> Thus, <span class="math display">\[\begin{align}
\bigl| V^{μ^*}(s) - W^*(s) \bigr| &amp;\stackrel{(a)}\le
\bigl| c(s,a) - c(\hat s,a) \bigr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|s,a) V^*(s&#39;) ds&#39; \biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^*(s&#39;) ds&#39; \biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^{*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) W^*(s&#39;) ds&#39; \biggr| 
\label{eq:step-c-1}
\end{align}\]</span> where <span class="math inline">\((a)\)</span> follows from the triangle inequality. Now, we bound each of the terms in \eqref{eq:step-b-1}. Since <span class="math inline">\(c\)</span> is Lipschitz, we have <span class="math display">\[\begin{equation} \label{eq:step-c-2}
\bigl| c(s,a) - c(\hat s,a) \bigr| \le L_c D.
\end{equation}\]</span> Moreover, from triangle inequality, we have <span class="math display">\[\begin{equation} \label{eq:step-c-3}
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|s,a) V^*(s&#39;) ds&#39; \biggr| 
\le \NORM{ V^{μ^*} - V^*}_∞.
\end{equation}\]</span> From the Kantorovich-Rubinstein duality, we have <span class="math display">\[\begin{equation} \label{eq:step-c-5}
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^*(s&#39;) ds&#39; \biggr| 
\le \mathcal {W}(p( \cdot | s,a), p(\cdot | \phi(s), a)) \NORM{V^*}_L
\le L_p D \NORM{V^*}_L.
\end{equation}\]</span> Finally, from triangle inequality and <a href="#prop:value" title="Proposition 2"><span class="pandoc-numbering-link prop">Proposition 2</span></a>, we have <span class="math display">\[\begin{equation} \label{eq:step-c-6}
\biggl| \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^{*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) W^*(s&#39;) ds&#39; \biggr| 
\le \NORM{V^* - W^*}_∞ \le \frac{D}{1-γ} \NORM{V^*}_L.
\end{equation}\]</span> Substituting \eqref{eq:step-c-2}–\eqref{eq:step-c-6} in \eqref{eq:step-c-1} and rearranging, we get <span class="math display">\[\begin{equation}\label{eq:step-c-7}
  \NORM{V^{μ^*} - W^*}_∞ \le D \biggl[
  L_c + γ L_p \NORM{V^*}_L + \frac{γ}{1-γ} \NORM{V^*}_L \biggr]
  + γ \NORM{V^{μ^*} - V^*}_∞.
\end{equation}\]</span></p>
<p>Now, by triangle inequality <span class="math display">\[\NORM{V^{μ^*} - V^*}_∞ \le \NORM{V^{μ^*} - W^*}_∞ + \NORM{V^* - W^*}_∞
\le  D \biggl[
  L_c + γ L_p \NORM{V^*}_L + \frac{1+γ}{1-γ} \NORM{V^*}_L \biggr]
  + γ \NORM{V^{μ^*} - V^*}.
\]</span> where the last inequality follows from <a href="#prop:value" title="Proposition 2"><span class="pandoc-numbering-link prop">Proposition 2</span></a> and \eqref{eq:step-c-7}. Rearranging the terms proves the first result of the Proposition. The second result follows from simple algebra.</p>
</div>
</details>
<details>
<summary>
<h4 class="unnumbered" id="alternative-proof">Alternative Proof</h4>
</summary>
<div>
<p>Fix a state <span class="math inline">\(s \in \ALPHABET S\)</span>. Let <span class="math inline">\(\hat s = \phi(s)\)</span> and <span class="math inline">\(a = \hat μ^*(\hat s) = μ^*(s)\)</span>. By construction, <span class="math inline">\(W^*(s) = \hat W^*(\hat s)\)</span>. Thus, <span class="math display">\[\begin{align*}
W^*(s) &amp;= \hat W^*(\hat s) = c(\hat s, a) + γ \sum_{\hat s&#39; \in \hat {\ALPHABET S}}
\hat P(\hat s&#39; | \hat s, a) \hat W^*(\hat s&#39;).
\\
&amp;= c(\hat s, a) + γ \int_{\ALPHABET S} p(s&#39; | \hat s, a) W^*(s&#39;) ds&#39;.
\end{align*}\]</span> Moreover, <span class="math display">\[
V^{μ^*}(s) = c(s, a) + γ \int_{\ALPHABET S} 
p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39;.
\]</span> Thus, <span class="math display">\[\begin{align}
\bigl| V^{μ^*}(s) - W^*(s) \bigr| &amp;\stackrel{(a)}\le
\bigl| c(s,a) - c(\hat s,a) \bigr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|s,a) W^*(s&#39;) ds&#39; \biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|s,a) W^{*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|s,a) V^*(s&#39;) ds&#39; \biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^*(s&#39;) ds&#39; \biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^{*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) W^*(s&#39;) ds&#39; \biggr| 
\label{eq:step-b-1}
\end{align}\]</span> where <span class="math inline">\((a)\)</span> follows from the triangle inequality. Now, we bound each of the terms in \eqref{eq:step-b-1}. Since <span class="math inline">\(c\)</span> is Lipschitz, we have <span class="math display">\[\begin{equation} \label{eq:step-b-2}
\bigl| c(s,a) - c(\hat s,a) \bigr| \le L_c D.
\end{equation}\]</span> Moreover, <span class="math display">\[\begin{equation} \label{eq:step-b-3}
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|s,a) W^*(s&#39;) ds&#39; \biggr| 
\le \NORM{ V^{μ^*} - W^*}_∞.
\end{equation}\]</span> From <a href="#prop:value" title="Proposition 2"><span class="pandoc-numbering-link prop">Proposition 2</span></a> we have <span class="math display">\[\begin{equation} \label{eq:step-b-4}
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) W^{*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|s,a) V^*(s&#39;) ds&#39; \biggr| 
\le \NORM{ W^* - V^*}_∞ \le \frac{D}{1-γ} \NORM{V^*}_L
\end{equation}\]</span> From the Kantorovich-Rubinstein duality, we have <span class="math display">\[\begin{equation} \label{eq:step-b-5}
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^*(s&#39;) ds&#39; \biggr| 
\le \mathcal {W}(p( \cdot | s,a), p(\cdot | \phi(s), a)) \NORM{V^*}_L
\le L_p D \NORM{V^*}_L.
\end{equation}\]</span> Finally, from <a href="#prop:value" title="Proposition 2"><span class="pandoc-numbering-link prop">Proposition 2</span></a>, we have <span class="math display">\[\begin{equation} \label{eq:step-b-6}
\biggl| \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^{*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) W^*(s&#39;) ds&#39; \biggr| 
\le \NORM{V^* - W^*}_∞ \le \frac{D}{1-γ} \NORM{V^*}_L.
\end{equation}\]</span> Substituting \eqref{eq:step-b-2}–\eqref{eq:step-b-6} in \eqref{eq:step-b-1} and rearranging, we get <span class="math display">\[\begin{equation}
  \NORM{V^{μ^*} - W^*}_∞ \le \frac{D}{1-γ} \biggl[
  L_c + γ L_p \NORM{V^*}_L + \frac{2γ}{1-γ} \NORM{V^*}_L \biggr]
\end{equation}\]</span></p>
<p>This proves the first result of the Proposition. The second result follows from simple algebra.</p>
</div>
</details>
<!--{{{ # Bounds in terms of Lipschitz constant of $\hat W^*$

When $γL_p < 1$, the bound in @prop:policy scales as $\mathcal{O}(1/(1-γ)^2)$
with the discount factor $γ$. In this section, we present a tighter scaling
with respect to the discount factor. 

## Preliminary results

First we define a metric $d_{\hat{\ALPHABET S}}$ on $\hat {\ALPHABET S}$ as
follows:
$$
d_{\hat {\ALPHABET S}}(\hat s, \hat s') = d_{\ALPHABET S}(\hat s, \hat s'),
\quad \forall \hat s, \hat s' \in \hat{\ALPHABET S}.
$$

Then, we have the following.

::: highlight :::
Lemma #lemma:lip

:   Under @ass:lip, the model $\hat M$ is $(L_c, 2L_p)$-Lipschitz MDP, i.e.,

    * For every $a \in \ALPHABET A$, $\hat c(\hat s, a)$ is $L_c$-Lipschitz in
      $\hat s$
    * For every $a \in \ALPHABET A$, $\hat P(\cdot | \hat s, a)$ is $L_p$-Lipschitz
      in $\hat s$ (with respect to the Kantorovich distance on probability measures). 

:::

#### Proof {-}

For any $a \in \ALPHABET A$ and $\hat s, \hat s' \in \hat {\ALPHABET S}$, we
have
$$\begin{align}
\bigl| \hat c(\hat s, a) - \hat c(\hat s', a) \bigr| 
&=
\bigl| c(\hat s, a) - c(\hat s', a) \bigr| 
\notag \\
&\stackrel{(a)}\le L_c d_{\ALPHABET S}(\hat s, \hat s')
\notag \\
&\stackrel{(b)}\le L_c d_{\hat {\ALPHABET S}}(\hat s, \hat s').
\label{eq:prop-1}
\end{align}$$
where $(a)$ follows from the fact that $c(s,a)$ is $L_c$-Lipschitz in $s$ and
$(b)$ follows from the definition of $d_{\hat {\ALPHABET S}}$.
Eq. \\eqref{eq:prop-1} implies that $\hat c(\hat s, a)$ is $L_c$-Lipschitz in
$\hat s$.

Proof of the second part TBW.

## Bounding the error for value function approximation

#### Proof {-}

Fix a state $s \in \ALPHABET S$. Let $\hat s = \phi(s)$ and $a = \hat
μ^*(\hat s) = μ^*(s)$. By construction, $W^*(s) = \hat W^*(\hat s)$. Thus, 
$$\begin{align*}
W^*(s) &= \hat W^*(\hat s) = c(\hat s, a) + γ \sum_{\hat s' \in \hat {\ALPHABET S}}
\hat P(\hat s' | \hat s, a) \hat W^*(\hat s').
\\
&= c(\hat s, a) + γ \int_{\ALPHABET S} p(s' | \hat s, a) W^*(s') ds'.
\end{align*}$$
Moreover, 
$$
V^{*}(s) = c(s, a) + γ \int_{\ALPHABET S} 
p(s'|s,a) V^{*}(s') ds'.
$$
Thus,
$$\begin{align}
\bigl| V^{*}(s) - W^*(s) \bigr| &\stackrel{(a)}\le
\bigl| c(s,a) - c(\phi(s),a) \bigr| \notag \\
&\quad + γ \biggl| \int_{\ALPHABET S} p(s'|s,a) V^{*}(s') ds' 
                -  \int_{\ALPHABET S} p(s'|s,a) W^*(s') ds' \biggr| \notag \\
&\quad + γ \biggl| \int_{\ALPHABET S} p(s'|s,a) W^{*}(s') ds' 
                -  \int_{\ALPHABET S} p(s'|\hat s,a) W^*(s') ds' \biggr|
\label{eq:prop-value-1}
\end{align}$$
Now we bound each term of \\eqref{eq:prop-value-1}. Note that $\bigl| c(s,a) -
c(\phi(s),a) \bigr|$ can be bound using \\eqref{eq:step-b-2}. Furthermore,
$$\begin{equation}
\biggl| \int_{\ALPHABET S} p(s'|s,a) V^{*}(s') ds' 
      -  \int_{\ALPHABET S} p(s'|s,a) W^*(s') ds' \biggr| 
\le \NORM{ V^* - W^* }_{∞}.
\label{eq:prop-value-2}
\end{equation}$$
Moreover, by Kantorovich-Rubinstein duality, we have
$$\begin{equation}
\biggl| \int_{\ALPHABET S} p(s'|s,a) W^{*}(s') ds' 
      -  \int_{\ALPHABET S} p(s'|\hat s,a) W^*(s') ds' \biggr|
\le 
\mathcal{W}(p(\cdot | s, a), \hat p(\cdot | \hat s, a)
\end{equation}$$

## Bounding the error for policy approximation
}}}-->
<h1 data-number="3" id="variations-of-a-theme"><span class="header-section-number">3</span> Variations of a theme</h1>
<p><span class="math inline">\(\newcommand\red[1]{{\color{red} #1}}\)</span> In the discussion above, we assumed that the approximate model <span class="math inline">\((\hat {\ALPHABET S}, \ALPHABET A, \hat P, \hat c)\)</span> was defined as follows: <span class="math display">\[ \hat c(\hat s, a) = c(s, a) 
 \quad\text{and}\quad
 \hat P(\hat s&#39; | \hat s, a) = p(\phi^{-1}(\hat s&#39;) | \hat s, a).
\]</span></p>
<p>A slightly general method of defining the approximate model is as follows. Consider a weight function <span class="math inline">\(α \colon \ALPHABET S \to [0,1]\)</span> which satisfies the following property: <span class="math display">\[\begin{equation}\label{eq:property}
 \int_{\phi^{-1}(\hat s)} α(s) ds = 1, 
 \quad \forall \hat s \in \hat {\ALPHABET S}.
\end{equation}\]</span> For example, such a weight function can be defined via an arbitrary measure <span class="math inline">\(λ\)</span> on <span class="math inline">\(\ALPHABET S\)</span> by viewing <span class="math inline">\(α(s)\)</span> as the conditional probability distribution <span class="math display">\[ α(s) = \dfrac{ λ(s) }{ λ(\phi^{-1}(\phi(s))) }, \]</span> which satisfies \eqref{eq:property} by construction.</p>
<p>Now given a weight function which satisfies \eqref{eq:property}, we can define an approximate model <span class="math inline">\((\hat {\ALPHABET S}, \ALPHABET A, \hat P, \hat c)\)</span> as follows: for all <span class="math inline">\(\hat s \in \hat {\ALPHABET S}\)</span> and <span class="math inline">\(a \in \ALPHABET A\)</span>,</p>
<p><span class="math display">\[\hat c(\hat s, a) = \int_{\phi^{-1}(\hat s)} c(s,a) α(s) ds
\quad\text{and}\quad
\hat P(\hat s&#39; | \hat s, a) = \int_{\phi^{-1}(s)} p(\phi^{-1}(\hat s&#39;) | s, a) α(s) ds.
\]</span> Note that if we take <span class="math inline">\(α(s) = \sum_{\hat s \in \hat {\ALPHABET S}}δ(s - \hat s)\)</span>, then we recover the approximation function used in the previous section.</p>
<p>Using a weighed approximate model does not fundamentally change any of the results. Here we rederive all the previous results for the weighted approximate model.</p>
<h2 data-number="3.1" id="preliminary-results-1"><span class="header-section-number">3.1</span> Preliminary results</h2>
<p>As before, we start by some preliminary results to build the intuition behind the approximation bounds. We start with a property of the discretized transition matrix.</p>
<div class="highlight">
<dl>
<dt><span id="lemma:3"></span><span id="lemma:pmf-w" class="pandoc-numbering-text lemma"><strong>Lemma 3</strong></span></dt>
<dd>
<p>For any <span class="math inline">\(\hat V \colon \hat {\ALPHABET S} \to \reals\)</span>, let <span class="math inline">\(V \colon \ALPHABET S \to \reals\)</span> be its piecewise constant extrapolation from <span class="math inline">\(\hat {\ALPHABET S}\)</span> to <span class="math inline">\(\ALPHABET S\)</span> (i.e., <span class="math inline">\(V = \hat V \circ \phi\)</span>). Then, for any <span class="math inline">\(\hat s_k \in \ALPHABET S\)</span> and <span class="math inline">\(a \in \ALPHABET A\)</span>, we have <span class="math display">\[
\int_{\ALPHABET S} \red{\int_{\hat {\ALPHABET S}_k}} p(s&#39; | \hat s_k,a) V(s&#39;) \red{α(s) ds} ds&#39; 
=
\sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat P(\hat s&#39; | \hat s_k, a) 
\hat V(\hat s&#39;).
\]</span></p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof-4">Proof</h4>
</summary>
<div>
<p>Recall that <span class="math inline">\(\{\ALPHABET S_1, \dots, \ALPHABET S_n\}\)</span> is a partition of <span class="math inline">\(\ALPHABET S\)</span> and <span class="math inline">\(\ALPHABET S_i = \phi^{-1}(\hat s_i)\)</span>. Therefore, <span class="math display">\[\begin{align*}
\int_{\ALPHABET S} \red{\int_{\hat {\ALPHABET S}_k}} p(s&#39; | s,a) V(s&#39;) \red{α(s) ds} ds&#39; 
&amp;=
\sum_{\hat s&#39;_i \in \hat {\ALPHABET S}} \int_{\hat {\ALPHABET S}_i}
\biggl[ \red{\int_{\hat{\ALPHABET S}_k}} p(s&#39; | \hat s,a) \red{α(s)
ds}\biggr] V(s&#39;) ds&#39; 
\\
&amp;=
\sum_{\hat s&#39; \in \hat {\ALPHABET S}}\hat V(\hat s&#39;_i)  \biggl[\int_{\hat
{\ALPHABET S}_i}
 \red{\int_{\hat{\ALPHABET S}_k}} p(s&#39; | s,a) \red{α(s)
ds}ds&#39; \biggr] 
\\
&amp;= \sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat V(\hat s&#39;) 
\hat P(\hat s&#39; | \hat s, a).
\end{align*}\]</span></p>
</div>
</details>
<p>As before, an immediate consequence of <a href="#lemma:pmf-w" title="Lemma 3"><span class="pandoc-numbering-link lemma">Lemma 3</span></a> is the following:</p>
<div class="highlight">
<dl>
<dt><span id="lemma:4"></span><span id="lemma:one-step-w" class="pandoc-numbering-text lemma"><strong>Lemma 4</strong></span></dt>
<dd>
<p>For any <span class="math inline">\(\hat V \colon \hat {\ALPHABET S} \to \reals\)</span>, let <span class="math inline">\(V \colon \ALPHABET S \to \reals\)</span> be its piecewise constant extrapolation from <span class="math inline">\(\hat {\ALPHABET S}\)</span> to <span class="math inline">\(\ALPHABET S\)</span> (i.e., <span class="math inline">\(V = \hat V \circ \phi\)</span>). As in <a href="#lemma:one-step" title="Lemma 2"><span class="pandoc-numbering-link lemma">Lemma 2</span></a>, define the one-step update functions: <span class="math display">\[\begin{align}
  W(s) &amp;= \min_{a \in \ALPHABET A}\biggl\{
  c(s,a) + γ \int_{\ALPHABET S} p(s&#39; | s,a) V(s&#39;) ds&#39; \biggr\}, 
  \label{eq:one-step-a-w}\\ 
  \hat W(\hat s) &amp;= \min_{a \in \ALPHABET  A} \biggl\{
  \hat c(\hat s,a) + γ \sum_{\hat s \in \ALPHABET S} \hat P(\hat s&#39; | s,a) \hat
  V(\hat s&#39;) \biggr\}.
  \label{eq:one-step-b-w}
\end{align}\]</span> Then, <span class="math display">\[\begin{equation}\label{eq:one-step-w}
  \red{\int_{\phi^{-1}(\hat s)}} W(s) \red{α(s) ds} = \hat W(\hat s), \quad \forall \hat s \in \hat {\ALPHABET S}.
\end{equation}\]</span></p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof-5">Proof</h4>
</summary>
<div>
<p>Let <span class="math inline">\(π\)</span> be the optimal policy for \eqref{eq:one-step-a-w} and <span class="math inline">\(\hat π\)</span> be the optimal policy for \eqref{eq:one-step-b-w}. Fix a state <span class="math inline">\(\hat s_k \in \hat {\ALPHABET S}\)</span> and let <span class="math inline">\(a = π(\hat s_k)\)</span> and <span class="math inline">\(\hat a = \hat π(\hat s_k)\)</span>. Then, <span class="math display">\[\begin{align*}
\red{\int_{\hat {\ALPHABET S}_k}} W(s) \red{α(s) ds} &amp;= 
\red{\int_{\hat {\ALPHABET S}_k}} c(s, a) \red{α(s) ds} + γ \int_{\ALPHABET S}
\red{\int_{\hat {\ALPHABET S}_k}} p( s&#39; | s, a)  V(s&#39;) \red{α(s) ds} ds&#39;
\\
&amp;\stackrel{(a)}= \hat c(\hat s_k, a) + γ
\sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat P(\hat s&#39;|\hat s_k, a) \hat V(\hat
s&#39;)
\\
&amp;\ge \hat W(\hat s_k),
\end{align*}\]</span> where <span class="math inline">\((a)\)</span> follows from definition of <span class="math inline">\(\hat c\)</span> and <a href="#lemma:pmf-w" title="Lemma 3"><span class="pandoc-numbering-link lemma">Lemma 3</span></a>.</p>
<p>Similarly, we have <span class="math display">\[\begin{align*}
\hat W(\hat s_k) &amp;= \hat c(\hat s_k, \hat a) + γ
\sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat P(\hat s&#39;|\hat s_k, \hat a) \hat V(\hat
s&#39;)
\\
&amp;\stackrel{(b)}= \red{\int_{\hat {\ALPHABET S}_k}} c(s, \hat a) \red{α(s) ds}
+ γ \int_{\ALPHABET S} \red{\int_{\hat {\ALPHABET S}_k} }
  P( s&#39; | s, \hat a)  V(s&#39;) \red{α(s) ds} ds&#39;
\\
&amp;\ge \red{\int_{\hat {\ALPHABET S}_k}} W(s) \red{α(s) ds},
\end{align*}\]</span> where <span class="math inline">\((b)\)</span> follows from definition of <span class="math inline">\(\hat c\)</span> and <a href="#lemma:pmf-w" title="Lemma 3"><span class="pandoc-numbering-link lemma">Lemma 3</span></a>.</p>
<p>Thus, <span class="math inline">\(\int_{\hat {\ALPHABET S}_k} W(s) α(s) ds = \hat W(\hat s_k)\)</span>.</p>
</div>
</details>
<p>The interpretations of <a href="#lemma:pmf-w" title="Lemma 3"><span class="pandoc-numbering-link lemma">Lemma 3</span></a> and <a href="#lemma:one-step-w" title="Lemma 4"><span class="pandoc-numbering-link lemma">Lemma 4</span></a> are similar to those of <a href="#lemma:pmf" title="Lemma 1"><span class="pandoc-numbering-link lemma">Lemma 1</span></a> and <a href="#lemma:one-step" title="Lemma 2"><span class="pandoc-numbering-link lemma">Lemma 2</span></a>. The one step Bellman update of any cost-to-go function <span class="math inline">\(\hat V \colon \ALPHABET S \to \reals\)</span> in the approximate model is the same as one-step Bellman update of its piecewise constant extrapolation <span class="math inline">\(V\)</span> <em>averaged</em> using the weight function <span class="math inline">\(α\)</span>.</p>
<h2 data-number="3.2" id="bounding-the-error-for-value-function-approximation-1"><span class="header-section-number">3.2</span> Bounding the error for value function approximation</h2>
<p>The intuition of bounding the value function approximation is the same as before. We assume that <span class="math inline">\(\ALPHABET S\)</span> is a bounded metric space with metric <span class="math inline">\(d_{\ALPHABET S}\)</span> and the orignal MDP satisfies regularity conditions (such as <a href="#ass:lip" title="Assumpt. 1"><span class="pandoc-numbering-link ass">Assumpt. 1</span></a>) such that the value function <span class="math inline">\(V^*\)</span> is Lipschitz with Lipschitz constant <span class="math inline">\(\NORM{V^*}_L\)</span>.</p>
<p>Then, as for <a href="#prop:value" title="Proposition 2"><span class="pandoc-numbering-link prop">Proposition 2</span></a>, we can show the following.</p>
<div class="highlight">
<dl>
<dt><span id="prop:4"></span><span id="prop:value-w" class="pandoc-numbering-text prop"><strong>Proposition 4</strong></span></dt>
<dd>
<p><a href="#prop:value" title="Proposition 2"><span class="pandoc-numbering-link prop">Proposition 2</span></a> holds for the weighted approximate model as well.</p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof-6">Proof</h4>
</summary>
<div>
<p>Consider any <span class="math inline">\(s \in \ALPHABET S\)</span>. Define the piecewise constant function <span class="math display">\[
  \bar V(s) = \int_{\phi^{-1}( \phi(s) )} V^*(s) α(s) ds.
\]</span> For the ease of notation, let <span class="math inline">\(\hat {\ALPHABET S}_k\)</span> denote the code cell where <span class="math inline">\(s\)</span> lies. Then, we can write <span class="math inline">\(\bar V(s) = \int_{\hat{\ALPHABET S}_k} V^*(s) α(s) ds\)</span> for all <span class="math inline">\(s \in \hat {\ALPHABET S}_k\)</span>. Note that, by Lipschitz continuity of <span class="math inline">\(V^*\)</span>, we have for any <span class="math inline">\(s \in \hat {\ALPHABET S}_k\)</span>, <span class="math display">\[\begin{align}
\bigl| V^*(s) - \bar V(s) \bigr| 
&amp;= \biggl| \int_{\hat {\ALPHABET S}_k} V^*(s) α(s&#39;) ds&#39; - \int_{\hat {\ALPHABET S}_k}
V^*(s&#39;) α(s&#39;) ds&#39; \biggr| 
\notag \\
&amp;\le \int_{\hat {\ALPHABET S}_k} \bigl| V^*(s) - V^*(s&#39;) \bigr| α(s&#39;) ds&#39; 
\notag \\
&amp;\stackrel{(a)}{\le} \int_{\hat {\ALPHABET S}_k} \NORM{V^*}_L D α(s&#39;) ds&#39; 
\notag \\
&amp;= \NORM{V^*}_L D
\label{eq:lip-w}
\end{align}\]</span> where <span class="math inline">\((a)\)</span> follows from \eqref{eq:lip}. Note that since the code cell <span class="math inline">\(\hat {\ALPHABET S}_k\)</span> was arbitrary, \eqref{eq:lip-w} holds for all <span class="math inline">\(s \in \ALPHABET S\)</span>. Thus, \eqref{eq:lip-w} may be viewed as the analog of \eqref{eq:lip} for the weighted model.</p>
<p>Now consider, <span class="math display">\[\begin{align}
  \bigl| V^*(s) - W^*(s) \bigr| 
  &amp;\le \bigl| V^*(s) - \bar V(s) \bigr| + \bigl| \bar V(s) - W^*(s) \bigr|
  \notag \\
  &amp;\le \NORM{V^*}_L D + \bigl| \bar V(s) -  W^*(s) \bigr|
  \label{eq:step-a-1-w}
\end{align}\]</span> where the first term follows from \eqref{eq:lip-w}.</p>
<p>Now we bound the second term. For the ease of notation let <span class="math inline">\(\mathcal B\)</span> and <span class="math inline">\(\hat {\mathcal B}\)</span> denote the Bellman operators for model <span class="math inline">\(M\)</span> and <span class="math inline">\(\hat M\)</span>, respectively. Without loss of generality, we assume that <span class="math inline">\(s \in \hat {\ALPHABET S}_k\)</span>. Then, <span class="math display">\[ \bar V(s) = \int_{\hat {\ALPHABET S}_k} V^*(s) α(s) ds
= \int_{\hat {\ALPHABET S}_k} [ \mathcal B V^*](s) α(s) ds.\]</span> Furthermore, <span class="math display">\[ W^*(s) = \hat W^*(\hat s_k) = [\hat {\mathcal B} \hat W^*](\hat s_k)
= \int_{\hat {\ALPHABET S}_k} [\mathcal B W^* ](s) α(s) ds,\]</span> where the last equality follows from <a href="#lemma:one-step-w" title="Lemma 4"><span class="pandoc-numbering-link lemma">Lemma 4</span></a>.</p>
<p>Combining the above two equations, we have <span class="math display">\[\begin{align}
\bigl| \bar V(s) - W^*(s) \bigr| &amp;\le
\int_{\hat {\ALPHABET S}_k} \bigl| [\mathcal B V^*](s) - [\mathcal B W^*](s)
\bigr| α(s) ds \notag \\
&amp;\le γ \NORM{V^* - W^*}_∞ \label{eq:step-a-2-w}
\end{align}\]</span></p>
<p>Substituting \eqref{eq:step-a-2-w} back in \eqref{eq:step-a-1-w}, we get <span class="math display">\[\bigl| V^*(s) - W^*(s) \bigr| \le \NORM{V^*}_L D + γ \NORM{V^* - W^*}_∞.\]</span> We get the result by supermizing over <span class="math inline">\(s\)</span> and rearranging the terms.</p>
</div>
</details>
<p>Note that since <a href="#cor:value" title="Corollary 1"><span class="pandoc-numbering-link cor">Corollary 1</span></a> only relies on the bound on <span class="math inline">\(\NORM{V^*}_L\)</span> it is also applicable to the weighted approximate model.</p>
<h2 data-number="3.3" id="bounding-the-error-for-policy-approximation-1"><span class="header-section-number">3.3</span> Bounding the error for policy approximation</h2>
<p>The bound and the proof for policy approximation goes through with very minor changes.</p>
<div class="highlight">
<dl>
<dt><span id="prop:5"></span><span id="prop:policy-w" class="pandoc-numbering-text prop"><strong>Proposition 5</strong></span></dt>
<dd>
<p><a href="#prop:policy" title="Proposition 3"><span class="pandoc-numbering-link prop">Proposition 3</span></a> holds for the weighted approximate model as well.</p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof-7">Proof</h4>
</summary>
<div>
<p>We will follow the alternative proof of <a href="#prop:policy" title="Proposition 3"><span class="pandoc-numbering-link prop">Proposition 3</span></a>. Fix a state <span class="math inline">\(s \in \ALPHABET S\)</span> and suppose <span class="math inline">\(s \in \hat {\ALPHABET S}_k\)</span>. Then <span class="math inline">\(\phi(s) = \hat s_k\)</span>. Let <span class="math inline">\(a = \hat μ^*(\hat s_k) = μ^*(s)\)</span>. By construction, <span class="math inline">\(W^*(s) = \hat W^*(\hat s_k)\)</span>. Thus, <span class="math display">\[\begin{align*}
W^*(s) &amp;= \hat W^*(\hat s_k) = \hat c(\hat s_k, a) + γ \sum_{\hat s&#39; \in \hat {\ALPHABET S}}
\hat P(\hat s&#39; | \hat s, a) \hat W^*(\hat s&#39;).
\\
&amp;= \red{\int_{\hat {\ALPHABET S}_k}}c(\tilde s, a) \red{α(\tilde s) d\tilde s}
+ γ \int_{\ALPHABET S} \red{\int_{\hat {\ALPHABET S}_k}}p(s&#39; | \tilde s, a)
  W^*(s&#39;)  \red{α(\tilde s) d\tilde s}ds&#39;.
\end{align*}\]</span> Moreover, <span class="math display">\[
V^{μ^*}(s) = c(s, a) + γ \int_{\ALPHABET S} 
p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39;.
\]</span> Thus, <span class="math display">\[\begin{align}
\bigl| V^{μ^*}(s) - W^*(s) \bigr| &amp;\stackrel{(a)}\le
\biggl| c(s,a) - \red{\int_{\hat {\ALPHABET S}_k}}c(\tilde s,a) \red{α(\tilde
s) d\tilde s}\biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|s,a) W^*(s&#39;) ds&#39; \biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|s,a) W^{*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|s,a) V^*(s&#39;) ds&#39; \biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S}\red{\int_{\hat {\ALPHABET S}_k}}
                   p(s&#39;|\tilde s,a) V^*(s&#39;) \red{α(\tilde s) d\tilde s}ds&#39; \biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} \red{\int_{\hat {\ALPHABET
S}_k}}p(s&#39;|\tilde s,a) V^{*}(s&#39;)\red{α(\tilde s) d\tilde s} ds&#39; 
                -  \int_{\ALPHABET S} \red{\int_{\hat {\ALPHABET
                   S}_k}}p(s&#39;|\tilde s,a) W^*(s&#39;)\red{α(\tilde s) d\tilde s} ds&#39; \biggr| 
\label{eq:step-b-1-w}
\end{align}\]</span> where <span class="math inline">\((a)\)</span> follows from the triangle inequality. Now, we bound each of the terms in \eqref{eq:step-b-1-w}. Since <span class="math inline">\(c\)</span> is Lipschitz and the weight function <span class="math inline">\(α\)</span> satisfies \eqref{eq:property}, we have <span class="math display">\[\begin{equation} \label{eq:step-b-2-w}
\biggl| c(s,a) - \red{\int_{\hat {\ALPHABET S}_k}}c(\tilde s,a) \red{α(\tilde
s) d\tilde s}\biggr| \le 
\red{\int_{\hat {\ALPHABET S}_k}} \bigl| c(s,a) - c(\tilde s,a) \bigr| \red{α(\tilde s) d\tilde s}\le L_c D.
\end{equation}\]</span> The next two terms can be bound as before. Fron triangle inequality, we have <span class="math display">\[\begin{equation} \label{eq:step-b-3-w}
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|s,a) W^*(s&#39;) ds&#39; \biggr| 
\le \NORM{ V^{μ^*} - W^*}_∞.
\end{equation}\]</span> From <a href="#prop:value-w" title="Proposition 4"><span class="pandoc-numbering-link prop">Proposition 4</span></a> we have <span class="math display">\[\begin{equation} \label{eq:step-b-4-w}
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) W^{*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|s,a) V^*(s&#39;) ds&#39; \biggr| 
\le \NORM{ W^* - V^*}_∞ \le \frac{D}{1-γ} \NORM{V^*}_L
\end{equation}\]</span> From the Kantorovich-Rubinstein duality, we have <span class="math display">\[\begin{align}
\hskip 2em &amp; \hskip -2em
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{*}(s&#39;) ds&#39; 
       -  \int_{\ALPHABET S}\red{\int_{\hat {\ALPHABET S}_k}}
          p(s&#39;|\tilde s,a) V^*(s&#39;) \red{α(\tilde s) d\tilde s}ds&#39; \biggr|
       \notag \\
&amp;\le 
\red{\int_{\hat {\ALPHABET S}_k}}
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{*}(s&#39;) ds&#39; 
       -  \int_{\ALPHABET S} p(s&#39;|\tilde s,a) V^*(s&#39;) ds&#39; \biggr| \red{α(\tilde s) d\tilde s}
       \notag \\
&amp;\le \mathcal {W}(p( \cdot | s,a), p(\cdot | \phi(s), a)) \NORM{V^*}_L
       \notag \\
&amp;\le L_p D \NORM{V^*}_L. \label{eq:step-b-5-w}
\end{align}\]</span> Finally, from <a href="#prop:value-w" title="Proposition 4"><span class="pandoc-numbering-link prop">Proposition 4</span></a>, we have <span class="math display">\[\begin{equation} \label{eq:step-b-6-w}
\biggl| \int_{\ALPHABET S} \red{\int_{\hat {\ALPHABET
S}_k}}p(s&#39;|\tilde s,a) V^{*}(s&#39;)\red{α(\tilde s) d\tilde s} ds&#39; 
                -  \int_{\ALPHABET S} \red{\int_{\hat {\ALPHABET
                   S}_k}}p(s&#39;|\tilde s,a) W^*(s&#39;)\red{α(\tilde s) d\tilde s} ds&#39; \biggr| 
\le \NORM{V^* - W^*}_∞ \le \frac{D}{1-γ} \NORM{V^*}_L.
\end{equation}\]</span> Substituting \eqref{eq:step-b-2}–\eqref{eq:step-b-6} in \eqref{eq:step-b-1} and rearranging, we get <span class="math display">\[\begin{equation}
  \NORM{V^{μ^*} - W^*}_∞ \le \frac{D}{1-γ} \biggl[
  L_c + γ L_p \NORM{V^*}_L + \frac{2γ}{1-γ} \NORM{V^*}_L \biggr]
\end{equation}\]</span></p>
<p>This proves the first result of the Proposition. The second result follows from simple algebra.</p>
</div>
</details>
<h1 class="unnumbered" id="references">References</h1>
<p>The results on state discretization (or quantization) first appeared in <span class="citation" data-cites="Bertsekas1975">Bertsekas (<a href="#ref-Bertsekas1975" role="doc-biblioref">1975</a>)</span>. The material here is adapted from <span class="citation" data-cites="Bertsekas1975">Bertsekas (<a href="#ref-Bertsekas1975" role="doc-biblioref">1975</a>)</span> and <span class="citation" data-cites="Hinderer2005">Hinderer (<a href="#ref-Hinderer2005" role="doc-biblioref">2005</a>)</span>. The alternative proof of <a href="#prop:policy" title="Proposition 3"><span class="pandoc-numbering-link prop">Proposition 3</span></a> is from <span class="citation" data-cites="Kara2021">Kara et al. (<a href="#ref-Kara2021" role="doc-biblioref">2021</a>)</span>.</p>
<p>The generalization to a weighted model is based on <span class="citation" data-cites="Li2006">Li et al. (<a href="#ref-Li2006" role="doc-biblioref">2006</a>)</span>. Similar model is also considered in <span class="citation" data-cites="Kara2021">Kara et al. (<a href="#ref-Kara2021" role="doc-biblioref">2021</a>)</span>.</p>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-Bertsekas1975" class="csl-entry" role="doc-biblioentry">
<span class="smallcaps">Bertsekas, D.</span> 1975. Convergence of discretization procedures in dynamic programming. <em>IEEE Transactions on Automatic Control</em> <em>20</em>, 3, 415–419. DOI: <a href="https://doi.org/10.1109/TAC.1975.1100984">10.1109/TAC.1975.1100984</a>.
</div>
<div id="ref-Hinderer2005" class="csl-entry" role="doc-biblioentry">
<span class="smallcaps">Hinderer, K.</span> 2005. Lipschitz continuity of value functions in <span>M</span>arkovian decision processes. <em>Mathematical Methods of Operations Research</em> <em>62</em>, 1, 3–22. DOI: <a href="https://doi.org/10.1007/s00186-005-0438-1">10.1007/s00186-005-0438-1</a>.
</div>
<div id="ref-Kara2021" class="csl-entry" role="doc-biblioentry">
<span class="smallcaps">Kara, A.D., Saldi, N., and Yüksel, S.</span> 2021. Q-learning for MDPs with general spaces: Convergence and near optimality via quantization under weak continuity. Available at: <a href="https://arxiv.org/abs/2111.06781v1">https://arxiv.org/abs/2111.06781v1</a>.
</div>
<div id="ref-Li2006" class="csl-entry" role="doc-biblioentry">
<span class="smallcaps">Li, L., Walsh, T.J., and Littman, M.L.</span> 2006. Towards a unified theory of state abstraction for <span>MDPs</span>. <em>ISAIM</em>. Available at: <a href="http://anytime.cs.umass.edu/aimath06/proceedings/P21.pdf">http://anytime.cs.umass.edu/aimath06/proceedings/P21.pdf</a>.
</div>
</div>


<p class="categories">
This entry 

 was last updated on 16 Jun 2022
 and posted in 

<a href="https://adityam.github.io/stochastic-control/categories/mdp">
  MDP</a>
and tagged
<a href="https://adityam.github.io/stochastic-control/tags/infinite-horizon">infinite horizon</a>,
<a href="https://adityam.github.io/stochastic-control/tags/discounted-cost">discounted cost</a>,
<a href="https://adityam.github.io/stochastic-control/tags/lipschitz-continuity">lipschitz continuity</a>,
<a href="https://adityam.github.io/stochastic-control/tags/approximation-bounds">approximation bounds</a>,
<a href="https://adityam.github.io/stochastic-control/tags/state-aggregation">state aggregation</a>.</p>



    </div>
  </body>
</html>


